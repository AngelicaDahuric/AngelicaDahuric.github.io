<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>How to learn Data Structure and Algorithm in ONE DAY | 白芷小姐の陋室</title><meta name="author" content="白芷"><meta name="copyright" content="白芷"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构课程期末复习 如果您的 C 语言有问题请去网上看 C 语言教程，请额外关注指针与结构体部分。 第一部分：思路 第二部分 把所有的填空题可能出现的代码粘上去 第三部分 做题技巧 总览本部分讲解数据结构的类型与实现 线性表（LinkList）线性表是一种线性结构，它由 $n$ 个数据元素 $a_1, a_2, …, a_n$ 组成。 逻辑结构线性表：数据元素之间是一对一的关系，即除第一个和最后">
<meta property="og:type" content="article">
<meta property="og:title" content="How to learn Data Structure and Algorithm in ONE DAY">
<meta property="og:url" content="https://angelicadahuric.github.io/2023/ds/index.html">
<meta property="og:site_name" content="白芷小姐の陋室">
<meta property="og:description" content="数据结构课程期末复习 如果您的 C 语言有问题请去网上看 C 语言教程，请额外关注指针与结构体部分。 第一部分：思路 第二部分 把所有的填空题可能出现的代码粘上去 第三部分 做题技巧 总览本部分讲解数据结构的类型与实现 线性表（LinkList）线性表是一种线性结构，它由 $n$ 个数据元素 $a_1, a_2, …, a_n$ 组成。 逻辑结构线性表：数据元素之间是一对一的关系，即除第一个和最后">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-12-19T21:20:59.000Z">
<meta property="article:modified_time" content="2024-07-24T00:42:10.776Z">
<meta property="article:author" content="白芷">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://angelicadahuric.github.io/2023/ds/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'How to learn Data Structure and Algorithm in ONE DAY',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-24 00:42:10'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-Bangumis"></i><span> Bangumis</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="白芷小姐の陋室"><span class="site-name">白芷小姐の陋室</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-Bangumis"></i><span> Bangumis</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">How to learn Data Structure and Algorithm in ONE DAY</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-19T21:20:59.000Z" title="发表于 2023-12-19 21:20:59">2023-12-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-24T00:42:10.776Z" title="更新于 2024-07-24 00:42:10">2024-07-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="How to learn Data Structure and Algorithm in ONE DAY"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>数据结构课程期末复习</p>
<p>如果您的 C 语言有问题请去网上看 C 语言教程，请额外关注指针与结构体部分。</p>
<p>第一部分：思路 第二部分 把所有的填空题可能出现的代码粘上去 第三部分 做题技巧</p>
<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>本部分讲解数据结构的类型与实现</p>
<h2 id="线性表（LinkList）"><a href="#线性表（LinkList）" class="headerlink" title="线性表（LinkList）"></a>线性表（LinkList）</h2><p>线性表是一种线性结构，它由 $n$ 个数据元素 $a_1, a_2, …, a_n$ 组成。</p>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>线性表：数据元素之间是一对一的关系，即除第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。</p>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p><img src="/images/ds/xxb.png" alt="线性表"></p>
<h4 id="顺序表（SeqList）"><a href="#顺序表（SeqList）" class="headerlink" title="顺序表（SeqList）"></a>顺序表（SeqList）</h4><p>（一句话：就是可动态增加空间的数组）</p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成数据的增删查改。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>支持随机访问，可以通过下标直接访问 </li>
<li>可以排序</li>
</ol>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>代码用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; arr;</span><br></pre></td></tr></table></figure>

<p>动态分配顺序表（复习用）</p>
<ol>
<li><p>建表及基本操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  OK  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  ERROR  -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//–––––线性表的动态分配顺序存储结构–––––</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE    30  <span class="comment">//线性表存储空间的初始分配</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> LISTINCREMENT     10  <span class="comment">//线性表存储空间的分配增量</span></span></span><br><span class="line"> <span class="keyword">typedef</span>   <span class="keyword">struct</span> &#123;</span><br><span class="line">  ElemType   *elem;      <span class="comment">//存储空间基址</span></span><br><span class="line">  <span class="type">int</span>        length;     <span class="comment">//当前长度</span></span><br><span class="line">  <span class="type">int</span>        listsize;   <span class="comment">//当前分配的存储容量(以sizeof(ElemType)为单位)</span></span><br><span class="line"> &#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------基本操作-----------------</span></span><br><span class="line"> <span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList  &amp;L)</span></span></span><br><span class="line"><span class="function"> </span>&#123; L.elem=(ElemType *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LIST_INIT_SIZE*<span class="built_in">sizeof</span>(ElemType)));</span><br><span class="line">   <span class="keyword">if</span>(!L.elem)<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">   L.length=<span class="number">0</span>;</span><br><span class="line">   L.listsize=LIST_INIT_SIZE;</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line"> &#125;<span class="comment">//InitList_Sq      算法2.3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength_Sq</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetElem_Sq</span><span class="params">(SqList L,<span class="type">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length) <span class="keyword">return</span> ERROR;</span><br><span class="line">  e=L.elem[i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//  在顺序线性表L中第i个位置之前插入新的元素e,</span></span><br><span class="line">  <span class="comment">//  i的合法值为1≤i≤ListLength_Sq(L)+1</span></span><br><span class="line">   ElemType *newbase,*p,*q;</span><br><span class="line">   <span class="keyword">if</span> (i&lt;<span class="number">1</span>||i&gt;L.length<span class="number">+1</span>) <span class="keyword">return</span> ERROR;     <span class="comment">//i 值不合法</span></span><br><span class="line">   <span class="keyword">if</span> (L.length&gt;=L.listsize)                <span class="comment">//当前存储空间已满,增加分配</span></span><br><span class="line">     &#123; newbase=(ElemType *)<span class="built_in">realloc</span>(L.elem,(L.listsize+LISTINCREMENT)*<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">      <span class="keyword">if</span>(!newbase)<span class="built_in">exit</span>(OVERFLOW);           <span class="comment">//存储分配失败</span></span><br><span class="line">      L.elem=newbase;                       <span class="comment">//新基址</span></span><br><span class="line">      L.listsize +=LISTINCREMENT;           <span class="comment">//增加存储容量</span></span><br><span class="line">    &#125;</span><br><span class="line">   q = &amp;L.elem[i<span class="number">-1</span>];                           <span class="comment">//q为插入位置</span></span><br><span class="line">   <span class="keyword">if</span>(L.length&gt;=<span class="number">1</span>)</span><br><span class="line">     <span class="keyword">for</span>(p=&amp;L.elem[L.length];p&gt;=q;--p)</span><br><span class="line">           *p = *(p<span class="number">-1</span>);</span><br><span class="line">   *q=e;                          <span class="comment">//插入e</span></span><br><span class="line">   L.length++;</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line"> &#125;<span class="comment">//ListInsert_Sq</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem_Sq</span><span class="params">(SqList L,ElemType e, Status (*compare)(ElemType,ElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> i; ElemType *p;</span><br><span class="line"> i = <span class="number">1</span>;</span><br><span class="line"> p = L.elem;                                  <span class="comment">//p的初值为第1个元素的存储位置</span></span><br><span class="line"> <span class="keyword">while</span>(i&lt;=L.length &amp;&amp; !(*compare)(*p++,e)) ++i;</span><br><span class="line"> <span class="keyword">if</span> (i&lt;=L.length)  <span class="keyword">return</span> i;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//LocateElem_Sq</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>例题</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数实现！</span></span><br><span class="line"><span class="comment">// 已知顺序线性表La和Lb的元素按值非递减排列，合并La和Lb得到新的顺序线性表Lc, Lc的元素也按值非递减排列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList_Sq</span><span class="params">(SqList La,SqList Lb, SqList &amp;Lc)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="type">int</span> i,j,k;</span><br><span class="line">  <span class="type">int</span> La_len,Lb_len;</span><br><span class="line">  ElemType ai,bj;</span><br><span class="line">  <span class="built_in">InitList_Sq</span>(Lc)</span><br><span class="line">  i=j=<span class="number">1</span>;k=<span class="number">0</span>;</span><br><span class="line">  La_len=La.length;</span><br><span class="line">  Lb_len=Lb.length;</span><br><span class="line">  <span class="keyword">while</span>((i&lt;=La_len) &amp;&amp; (j&lt;=Lb_len))        <span class="comment">//La和Lb均为空</span></span><br><span class="line">   &#123; <span class="built_in">GetElem_Sq</span>(La,i,ai);<span class="built_in">GetElem_Sq</span>(Lb,j,bj);</span><br><span class="line">     <span class="keyword">if</span>(ai&lt;=bj) &#123;<span class="built_in">ListInsert_Sq</span>(Lc, ++k, ai);++i;&#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;<span class="built_in">ListInsert_Sq</span>(Lc, ++k, bj);++j;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=La_len)</span><br><span class="line">   &#123; <span class="built_in">GetElem_Sq</span>(La, i++, ai); <span class="built_in">ListInsert_Sq</span>(Lc, ++k, ai);&#125;</span><br><span class="line">  <span class="keyword">while</span>(j&lt;=Lb_len)</span><br><span class="line">   &#123; <span class="built_in">GetElem_Sq</span>(Lb, j++, bj); <span class="built_in">ListInsert_Sq</span>(Lc, ++k, bj);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针实现！</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList_Sq</span><span class="params">(SqList La,SqList Lb, SqList &amp;Lc)</span></span></span><br><span class="line"><span class="function"></span>&#123;ElemType *pa,*pb,*pc,*pa_last,*pb_last;</span><br><span class="line"> pa = La.elem;</span><br><span class="line"> pb = Lb.elem;</span><br><span class="line"> Lc.listsize = Lc.length = La.length + Lb.length;</span><br><span class="line"> pc = Lc.elem =(ElemType *)<span class="built_in">malloc</span>(Lc.listsize * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line"> <span class="keyword">if</span> (!Lc.elem) <span class="built_in">exit</span>(OVERFLOW);            <span class="comment">//存储分配失败</span></span><br><span class="line"> pa_last = La.elem + La.length - <span class="number">1</span>;</span><br><span class="line"> pb_last = Lb.elem + Lb.length - <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> (pa&lt;=pa_last &amp;&amp; pb&lt;=pb_last)       <span class="comment">//归并</span></span><br><span class="line">  &#123;<span class="keyword">if</span> ( *pa&lt;= *pb) *pc++ = *pa++;</span><br><span class="line">   <span class="keyword">else</span> *pc++ = *pb++;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">while</span>( pa &lt;= pa_last )  *pc++=*pa++;</span><br><span class="line"> <span class="keyword">while</span>( pb &lt;= pb_last )  *pc++=*pb++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表（Link-List）"><a href="#链表（Link-List）" class="headerlink" title="链表（Link List）"></a>链表（Link List）</h4><p>比较重要！</p>
<h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p>
<p><img src="/images/ds/lb.png" alt="链表"></p>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ol>
<li>插入删除速度快 </li>
<li>内存利用率高 </li>
<li>大小没有固定，拓展很灵活</li>
</ol>
<h5 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h5><ol>
<li>节点</li>
</ol>
<p>链表的一个数据单元，结构分为数据域和指针域。</p>
<p>下面为一个单链表节点示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">   ElementType data;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">node</span> *next;</span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure>

<ol>
<li>单链表</li>
</ol>
<p>  每个节点具有数据域和一个指向后继节点的指针的链表</p>
<ol start="3">
<li>双链表</li>
</ol>
<p>每个节点具有数据域和两个分别指向前驱节点和后继节点的指针的链表</p>
<ol start="4">
<li>循环链表</li>
</ol>
<p>将单链表的最后一个节点的指针域由NULL改为指向第一个节点从而首尾相连的链表</p>
<ol start="5">
<li>头指针</li>
</ol>
<p>  头指针是链表的必要结构，意思为：指向链表第一个节点的指针。</p>
<p>  头指针具有标识作用，一般用头指针来作为链表的名字<br>  比如后文代码中的L。</p>
<ol start="6">
<li>头节点</li>
</ol>
<p>在链表的开始节点之前的设立的节点叫做头结点，头结点的数据域可以不存任何数据，也可以储存链表长度等数据，next指针域指向开始节点。</p>
<p>注：链表一般都含有头结点</p>
<ol start="7">
<li>尾指针</li>
</ol>
<p>  指向链表最后一个节点的指针。</p>
<ol start="8">
<li>尾结点</li>
</ol>
<p>尾结点指链表中最后一个结点，他的指针域为NULL。<br>&#x2F;&#x2F; 图</p>
<p>由以上概念排列组合可以得到：</p>
<p>带头结点的单链表，头指针是？尾指针是？尾结点是？</p>
<p>带头结点的双链表，头指针是？尾指针是？尾结点是？</p>
<p>带头结点的仅有尾指针的单循环链表</p>
<p>其相比仅有头指针的单循环链表的优点：往尾部插入节点和删除第一个节点的时间复杂度都是O(1)。</p>
<p>而仅有头指针的单循环链表往尾部插入节点的时间复杂度是O(n),即要遍历到尾部才可以插入。</p>
<h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><ol>
<li><p>建立</p>
<p>尾插法：</p>
<p>将新节点逐个从最末端的节点插入链表。</p>
<p>头插法：</p>
<p>利用指针指向下一个结点元素的方式进行逐个创建，使用头插入法最终得到的结果是逆序的。（也可以理解为从头节点不停的尾插节点）</p>
</li>
<li><p>遍历</p>
</li>
</ol>
<p>通过指针访问直接遍历即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printLinkedList</span><span class="params">(<span class="keyword">struct</span> Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* p = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>插入</li>
</ol>
<p>遇事不决就画图</p>
<p>插入可分为三种情况</p>
<p>1.头部插入（插入在头节点后面）2.中间节点插入3.尾部插入（插入到尾部，next指针指NULL）</p>
<p>单链表的插入</p>
<p><img src="/images/ds/link-insert.png" alt="单链表插入"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在带头结点的单线性链表L中第i个位置之前插入元素e</span></span><br><span class="line"> LinkList p,s; <span class="type">int</span> j;</span><br><span class="line"> p = L; j = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> ( p &amp;&amp; j&lt;i<span class="number">-1</span> )</span><br><span class="line">      &#123; p = p-&gt;next; ++j; &#125;          <span class="comment">//寻找第i-1个结点</span></span><br><span class="line"> <span class="keyword">if</span>  (!p||j&gt;i<span class="number">-1</span>)  <span class="keyword">return</span> ERROR;     <span class="comment">//i 小于1或者大于表长</span></span><br><span class="line"> s = (LinkList )<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));   <span class="comment">//生成新结点</span></span><br><span class="line"> s-&gt;data = e; s-&gt;next = p-&gt;next;                 <span class="comment">//插入L中</span></span><br><span class="line"> p-&gt;next = s;</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双链表的插入</p>
<p><img src="/images/ds/doublelinked-insert.png" alt="双链表插入"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在p结点之后插入s结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *P, DNode *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s-&gt;next = p-&gt;next;	<span class="comment">//将结点*s插入到结点*p之后， 如上图步骤1</span></span><br><span class="line">	p-&gt;next-&gt;prior = s;  <span class="comment">//如上图步骤2</span></span><br><span class="line">	s-&gt;prior = p;     <span class="comment">//如上图步骤3</span></span><br><span class="line">	p-&gt;next = s;      <span class="comment">//如上图步骤4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>搜索<br>遍历的同时寻找节点的数据，代码同遍历。</li>
<li>删除</li>
</ol>
<p>单链表删除</p>
<p><img src="/images/ds/delete.png" alt="单链表删除"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i,  ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 在带头结点的单链线性表L中,删除第i个元素,并由e返回其值</span></span><br><span class="line"> <span class="type">int</span> j;</span><br><span class="line"> LinkList p,q;</span><br><span class="line"> p = L;  j = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>( p-&gt;next &amp;&amp; j&lt;i<span class="number">-1</span> )</span><br><span class="line">  &#123; p = p-&gt;next; ++j; &#125;      <span class="comment">//寻找第i个元素,并令p指向其前驱</span></span><br><span class="line"> <span class="keyword">if</span> (!(p-&gt;next)||j&gt;i<span class="number">-1</span>)  <span class="keyword">return</span> ERROR;   <span class="comment">//删除位置不合理</span></span><br><span class="line"> q = p-&gt;next;   </span><br><span class="line"> p-&gt;next = q-&gt;next;             <span class="comment">//删除并释放结点</span></span><br><span class="line"> e = q-&gt;data;</span><br><span class="line"> <span class="built_in">free</span>(q);</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双链表删除</p>
<p><img src="/images/ds/delete.png" alt="双链表删除"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除p的后继结点q,</span></span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><ol>
<li><p>单链表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//–––––线性表的链式存储结构–––––</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span>  <span class="title class_">LNode</span></span><br><span class="line">&#123;  ElemType       data;</span><br><span class="line">  <span class="keyword">struct</span>  <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------基本操作-----------------</span></span><br><span class="line"><span class="function">Status <span class="title">InitList_L</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//建立一个空的链表，L为带头结点的单链表的头指针.</span></span><br><span class="line">   L=(LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));   <span class="comment">//生成头结点</span></span><br><span class="line">   <span class="keyword">if</span>(!L) <span class="keyword">return</span> ERROR;</span><br><span class="line">   L-&gt;next=<span class="literal">NULL</span>; </span><br><span class="line">     <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">//InitList_L</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在带头结点的单线性链表L中第i个位置之前插入元素e</span></span><br><span class="line"> LinkList p,s; <span class="type">int</span> j;</span><br><span class="line"> p = L; j = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> ( p &amp;&amp; j&lt;i<span class="number">-1</span> )</span><br><span class="line">      &#123; p = p-&gt;next; ++j; &#125;          <span class="comment">//寻找第i-1个结点</span></span><br><span class="line"> <span class="keyword">if</span>  (!p||j&gt;i<span class="number">-1</span>)  <span class="keyword">return</span> ERROR;     <span class="comment">//i 小于1或者大于表长</span></span><br><span class="line"> s = (LinkList )<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));   <span class="comment">//生成新结点</span></span><br><span class="line"> s-&gt;data = e; s-&gt;next = p-&gt;next;                 <span class="comment">//插入L中</span></span><br><span class="line"> p-&gt;next = s;</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//ListInsert_L</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem_L</span><span class="params">(LinkList L,ElemType e, Status (*compare)(ElemType,ElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//在线性链表L中查找第1个值与e满足compare()的元素的位序</span></span><br><span class="line">  <span class="comment">//若找到,则返回其在L中的位序,否则返回0</span></span><br><span class="line"> <span class="type">int</span> i; LinkList p;</span><br><span class="line"> i = <span class="number">1</span>;                                            <span class="comment">//i的初值为第1个元素的位序</span></span><br><span class="line"> p = L-&gt;next;                         <span class="comment">//p的初值为第1个元素的存储位置</span></span><br><span class="line"> <span class="keyword">while</span>(  p &amp;&amp; !<span class="built_in">compare</span>(p-&gt;data, e) )</span><br><span class="line"> &#123;  ++i; p=p-&gt;next;&#125;</span><br><span class="line"> <span class="keyword">if</span> (p) <span class="keyword">return</span> i;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;<span class="comment">//LocateElem_Sq</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList L, <span class="type">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//L为带头结点的单链表的头指针.</span></span><br><span class="line">  <span class="comment">//当第i个元素存在时,其值赋给e并返回OK,否则返回ERROR</span></span><br><span class="line"> LinkList p; <span class="type">int</span> j;</span><br><span class="line">  p = L-&gt;next; </span><br><span class="line">  j = <span class="number">1</span>; </span><br><span class="line"> <span class="keyword">while</span> ( p&amp;&amp; j&lt;i )</span><br><span class="line">  &#123;                   <span class="comment">//顺指针向后查找,直到p指向第i个元素或p为空</span></span><br><span class="line">   j++; p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">if</span> (!p||j&gt;i)  <span class="keyword">return</span> ERROR ;          <span class="comment">//第i个元素不存在</span></span><br><span class="line"> e = p-&gt;data;                           <span class="comment">//取第i个元素</span></span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">//GetElem_L</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListEmpty_L</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> TRUE;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength_L</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;LinkList p;</span><br><span class="line"> <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line"> p=L-&gt;next;</span><br><span class="line"> <span class="keyword">while</span>(p)</span><br><span class="line"> &#123;</span><br><span class="line">    len++; p = p-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i,  ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 在带头结点的单链线性表L中,删除第i个元素,并由e返回其值</span></span><br><span class="line"> <span class="type">int</span> j;</span><br><span class="line"> LinkList p,q;</span><br><span class="line"> p = L;  j = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>( p-&gt;next &amp;&amp; j&lt;i<span class="number">-1</span> )</span><br><span class="line">  &#123; p = p-&gt;next; ++j; &#125;      <span class="comment">//寻找第i个元素,并令p指向其前驱</span></span><br><span class="line"> <span class="keyword">if</span> (!(p-&gt;next)||j&gt;i<span class="number">-1</span>)  <span class="keyword">return</span> ERROR;   <span class="comment">//删除位置不合理</span></span><br><span class="line"> q = p-&gt;next;   </span><br><span class="line"> p-&gt;next = q-&gt;next;             <span class="comment">//删除并释放结点</span></span><br><span class="line"> e = q-&gt;data;</span><br><span class="line"> <span class="built_in">free</span>(q);</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双向链表</p>
</li>
</ol>
<p>非书上代码仅供参考,From<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44162361/article/details/115819742">CSDN薛定谔的猫ovo</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *prior,*next;</span><br><span class="line">&#125;DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DLinkList));</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line">    DNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求双链表的长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Length</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line">    DNode *p = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法建立双链表</span></span><br><span class="line"><span class="function">DLinkList <span class="title">HeadInsert</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitList</span>(L); <span class="comment">//初始化</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        DNode *s = (DNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            s-&gt;prior = L;</span><br><span class="line">            L-&gt;next = s;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s-&gt;next = L-&gt;next;</span><br><span class="line">            L-&gt;next-&gt;prior = s;</span><br><span class="line">            s-&gt;prior = L;</span><br><span class="line">            L-&gt;next = s;</span><br><span class="line">        &#125;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法建立双链表</span></span><br><span class="line"><span class="function">DLinkList <span class="title">TailInsert</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line">    DNode *s,*r=L;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s = (DNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;prior = r;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找：查找x在L中的位置</span></span><br><span class="line"><span class="function">DNode *<span class="title">LocateElem</span><span class="params">(DLinkList L, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    DNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data != x)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位查找：查找在双链表L中第i个位置的结点</span></span><br><span class="line"><span class="function">DNode *<span class="title">GetElem</span><span class="params">(DLinkList L, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    DNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)<span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//如果i大于表长，p=NULL,直接返回p即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插入到双链表L中*p结点的下一个结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(DLinkList &amp;L, DNode *p, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    DNode *s = (DNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作:将双链表中的第i个结点删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(DLinkList &amp;L, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;<span class="built_in">Length</span>(L))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;delete failed: index is wrong.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DNode *p = <span class="built_in">GetElem</span>(L,i<span class="number">-1</span>);</span><br><span class="line">    DNode *q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;L is null&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;L is not null&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//尾插法建立双链表，并遍历单链表</span></span><br><span class="line">    DLinkList L = <span class="built_in">TailInsert</span>(L);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;L: &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">    </span><br><span class="line">    DNode *p;</span><br><span class="line">    <span class="comment">//按值查找</span></span><br><span class="line">    p = <span class="built_in">LocateElem</span>(L,<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;值为2的结点的下一个结点值是：&quot;</span>&lt;&lt;p-&gt;next-&gt;data&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;值为2的结点的上一个结点值是：&quot;</span>&lt;&lt;p-&gt;prior-&gt;data&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//按位查找</span></span><br><span class="line">    p = <span class="built_in">GetElem</span>(L,<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;第三个结点值是：&quot;</span>&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入操作</span></span><br><span class="line">    <span class="built_in">Insert</span>(L,p,<span class="number">7</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;在第三个结点后面插入值为7的结点后L： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    <span class="built_in">Delete</span>(L, <span class="number">5</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;删除第五个结点后L： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求表长</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;表长为：&quot;</span>&lt;&lt;<span class="built_in">Length</span>(L)&lt;&lt;endl;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判空</span></span><br><span class="line">    <span class="built_in">Empty</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>循环链表<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//–––––线性表的链式存储结构–––––</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span>  <span class="title class_">LNode</span></span><br><span class="line">&#123;  ElemType       data;</span><br><span class="line">   <span class="keyword">struct</span>  <span class="title class_">LNode</span>  *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------基本操作-----------------</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//建立一个空的链表，L为头结点指针.</span></span><br><span class="line">   L=(LinkList )<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));   <span class="comment">//生成头结点</span></span><br><span class="line">   <span class="keyword">if</span>(!L) <span class="keyword">return</span> ERROR;</span><br><span class="line">   </span><br><span class="line">L-&gt;next=L;</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">//InitList</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DestroyList</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123; LinkList p,q;</span><br><span class="line">  p=L-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(p!=L)</span><br><span class="line">  &#123;q=p-&gt;next;</span><br><span class="line">   <span class="built_in">free</span>(p);</span><br><span class="line">   p=q;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(L);</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListEmpty</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span> (L-&gt;next==L) <span class="keyword">return</span> TRUE;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//L为带头结点的循环单链表的头指针.</span></span><br><span class="line">  <span class="comment">//当第i个元素存在时,其值赋给e并返回OK,否则返回ERROR</span></span><br><span class="line"> LinkList p; <span class="type">int</span> j;</span><br><span class="line"> p =L-&gt;next;</span><br><span class="line"> j= <span class="number">1</span>;      <span class="comment">//初始化,p指向第一个结点,j为计数器</span></span><br><span class="line"> <span class="keyword">while</span> (j!=i&amp;&amp;p!=L)</span><br><span class="line">  &#123;                   <span class="comment">//顺指针向后查找,直到p指向第i个元素</span></span><br><span class="line">    p = p-&gt;next ;   ++j;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">if</span> (p==L||j&gt;i)  <span class="keyword">return</span> ERROR ;          <span class="comment">//第i个元素不存在</span></span><br><span class="line"> e =p-&gt;data;                                               <span class="comment">//取第i个元素</span></span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">//GetElem</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在带头结点的循环链表L中第i个位置之前插入元素e</span></span><br><span class="line"> LinkList p,s; <span class="type">int</span> j;</span><br><span class="line"> p = L; j = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> ( (p-&gt;next!=L)&amp;&amp;(j!=i<span class="number">-1</span>))</span><br><span class="line">      &#123; p = p-&gt;next; ++j; &#125;                     <span class="comment">//寻找第i-1个结点</span></span><br><span class="line"> <span class="keyword">if</span>  (  j&gt;i<span class="number">-1</span>||j&lt;i<span class="number">-1</span>)  <span class="keyword">return</span> ERROR; <span class="comment">//i 小于1或者大于表长</span></span><br><span class="line"> s = (LinkList )<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));   <span class="comment">//生成新结点</span></span><br><span class="line"> <span class="keyword">if</span>(!s) <span class="keyword">return</span> ERROR;</span><br><span class="line"> s-&gt;data = e; </span><br><span class="line"> s-&gt;next = p-&gt;next;                 <span class="comment">//插入L中</span></span><br><span class="line"> p-&gt;next=s;</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i,  ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 在带头结点的循环单链线性表L中,删除第i个元素,并由e返回其值</span></span><br><span class="line"> <span class="type">int</span> j;</span><br><span class="line"> LinkList p,q;</span><br><span class="line"> p = L;  j =<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>( (p-&gt;next!=L)&amp;&amp;(j!=i<span class="number">-1</span>))</span><br><span class="line">  &#123; p = p-&gt;next; ++j; &#125;      <span class="comment">//寻找第i个元素,并令p指向其前驱</span></span><br><span class="line"> <span class="keyword">if</span> (j&lt;i<span class="number">-1</span>||j&gt;i<span class="number">-1</span>)  <span class="keyword">return</span> ERROR;   <span class="comment">//删除位置不合理</span></span><br><span class="line"> q = p-&gt;next;</span><br><span class="line"> p-&gt;next = q-&gt;next;             <span class="comment">//删除并释放结点</span></span><br><span class="line"> e = q-&gt;data;</span><br><span class="line"> <span class="built_in">free</span>(q);</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h2><p>先进后出，后进先出是栈</p>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>栈（Stack）：是操作受限的只允许在一端进行插入或删除的线性表。</p>
<p>栈顶（Top）：线性表允许进行插入删除的那一端。</p>
<p>栈底（Bottom）：固定的，不允许进行插入和删除的另一端。</p>
<p>空栈：不含任何元素的空表。</p>
<h3 id="栈的顺序储存结构"><a href="#栈的顺序储存结构" class="headerlink" title="栈的顺序储存结构"></a>栈的顺序储存结构</h3><h4 id="栈的顺序储存"><a href="#栈的顺序储存" class="headerlink" title="栈的顺序储存"></a>栈的顺序储存</h4><p>采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底（base）到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的下一个位置。</p>
<p>若存储栈的长度为stacksize，则栈顶位置top必须小于stacksize。当栈存在一个元素时，下标为0所以top等于0，因此通常把空栈的判断条件定位top等于-1。（本文代码将top&#x3D;&#x3D;base作为判定条件）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE   100       <span class="comment">//存储空间初始分配</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKINCREMENT  10       <span class="comment">//存储空间分配增量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;SElemType *base;<span class="comment">//开空间的base</span></span><br><span class="line"> SElemType *top; <span class="comment">//栈顶指针</span></span><br><span class="line"> <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="栈的操作及代码"><a href="#栈的操作及代码" class="headerlink" title="栈的操作及代码"></a>栈的操作及代码</h4><ol>
<li>初始化<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;s.base=(SElemType *)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="built_in">sizeof</span>(SElemType));</span><br><span class="line"> <span class="keyword">if</span> (!s.base) <span class="built_in">exit</span>(OVERFLOW);            <span class="comment">//存储分配失败</span></span><br><span class="line"> s.top=s.base;</span><br><span class="line"> s.stacksize = STACK_INIT_SIZE;</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>获得栈顶元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack s, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span>(s.top == s.base) <span class="keyword">return</span> ERROR;</span><br><span class="line">  e=*(s.top - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>push元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;s,SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//插入元素e为新的栈顶元素</span></span><br><span class="line">  <span class="keyword">if</span>(s.top-s.base&gt;=s.stacksize)</span><br><span class="line">  &#123;<span class="comment">//栈满,追加存储空间</span></span><br><span class="line">   s.base = (SElemType*)<span class="built_in">realloc</span>(s.base, (s.stacksize+STACKINCREMENT)*<span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">   <span class="keyword">if</span>(!s.base)<span class="built_in">exit</span>(OVERFLOW);           <span class="comment">//存储分配失败</span></span><br><span class="line">   s.top = s.base + s.stacksize;</span><br><span class="line">   s.stacksize +=STACKINCREMENT;</span><br><span class="line">  &#125;</span><br><span class="line">  *s.top++ = e;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>弹出元素pop<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;s,SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span>(s.top == s.base) <span class="keyword">return</span> ERROR;</span><br><span class="line">  e=*(--s.top);</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>判空<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack s)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span>(s.top==s.base) <span class="keyword">return</span> OK;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="栈的链式储存结构"><a href="#栈的链式储存结构" class="headerlink" title="栈的链式储存结构"></a>栈的链式储存结构</h3><p>链栈，顾名思义：采用链式存储结构实现的栈称为链栈。</p>
<h4 id="栈的链式储存"><a href="#栈的链式储存" class="headerlink" title="栈的链式储存"></a>栈的链式储存</h4><p>链栈通常采用单链表来实现，因此其结构与单链表的结构相同。</p>
<h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><p>由于栈的插入和删除操作仅限制在栈顶位置进行，所以采用单链表的头指针作为栈顶指针。</p>
<p>同时，为了操作方便，使用带头节点的单链表来实现链表。数据入栈或出栈时，使表头节点的指针指向新的表首节点即可，再入栈时，需要为新的数据元素动态的开辟存储单元，并修改头结点的指针域；而在出栈时，除了改变头结点的指针域，还要释放原栈顶元素所占用的空间。</p>
<p>其余的操作思路和顺序栈一致，代码和链表一致</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>非书上代码仅供参考，From <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_48701521/article/details/107687403">CSDN:九芒星#</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkedStackNode</span> </span><br><span class="line">&#123;	</span><br><span class="line">	elemtype data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkedStackNode</span> * next;</span><br><span class="line">&#125; LinkedStackNode, * LinkedStack;                                  </span><br><span class="line">  LinkedStack top;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function">LinkedStack <span class="title">Init_LinkedStack</span><span class="params">()</span>                                       </span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	LinkedStack top=(LinkedStackNode * )<span class="built_in">malloc</span> (<span class="built_in">sizeof</span>( LinkedStackNode));</span><br><span class="line">	<span class="keyword">if</span>(top!=<span class="literal">NULL</span>)<span class="comment">//申请空间成功</span></span><br><span class="line">	top-&gt;next=<span class="literal">NULL</span>;<span class="comment">//设置栈顶指针为空</span></span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判栈空</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LinkedStack_Empty</span><span class="params">(LinkedStack top)</span>                            </span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">if</span>(top-&gt;next==<span class="literal">NULL</span>)<span class="comment">//检查栈顶指针的值 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//栈S为空，函数返回1</span></span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Push_LinkedStack</span><span class="params">(LinkedStack top,elemtype x)</span>                     </span></span><br><span class="line"><span class="function">	<span class="comment">//插入数据元素x为新的栈顶元素</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	LinkedStackNode * node;</span><br><span class="line">	node=(LinkedStackNode * )<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkedStackNode));</span><br><span class="line">	<span class="keyword">if</span>(node==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//申请结点空间失败,插入失败，函数返回0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		node-&gt;data=x;<span class="comment">//设置新结点的数据域</span></span><br><span class="line">		node-&gt;next=top-&gt;next;<span class="comment">//设置新结点的指针城</span></span><br><span class="line">		top-&gt;next=node;<span class="comment">//设置头结点指针城指向新的栈顶元素</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//插入成功，函数返回1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求栈长</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Length_LinkedStack</span><span class="params">(LinkedStack top)</span>                                       </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(top-&gt;next!=<span class="literal">NULL</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		++count;</span><br><span class="line">		top=top-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pop_LinkedStack</span><span class="params">(LinkedStack top, elemtype *x)</span>                    </span></span><br><span class="line"><span class="function"></span>&#123;	LinkedStackNode * node;</span><br><span class="line">	<span class="keyword">if</span>(top-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		node=top-&gt;next;<span class="comment">//将原栈顶数据元素弹出并赋给node</span></span><br><span class="line">		*x=node-&gt;data;<span class="comment">//将原栈顶数据元素的数据赋值给x</span></span><br><span class="line">		top-&gt;next=node-&gt;next;<span class="comment">//top指向链栈中的下一个数据元素</span></span><br><span class="line">		<span class="built_in">free</span> (node);<span class="comment">//释放原栈顶数据元素所占的空间</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//取栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetTop_LinkedStack</span><span class="params">(LinkedStack top)</span>                </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(top-&gt;next)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">return</span> top-&gt;next-&gt;data;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,t,x,a[<span class="number">20</span>];</span><br><span class="line">	LinkedStack top=<span class="built_in">Init_LinkedStack</span>();<span class="comment">//初始化栈</span></span><br><span class="line">	x=<span class="built_in">LinkedStack_Empty</span>(top);<span class="comment">//判栈空结果赋值给X</span></span><br><span class="line">	<span class="keyword">if</span>(x=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;栈为空\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请依次输入5个数,开始入栈：\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">		<span class="built_in">Push_LinkedStack</span>(top,a[i]);</span><br><span class="line">		x=<span class="built_in">GetTop_LinkedStack</span>(top);</span><br><span class="line">		<span class="keyword">if</span>(x!=<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;当前栈顶元素为%d\n&quot;</span>,x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;入栈结束\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;栈长为%d\n&quot;</span>,<span class="built_in">Length_LinkedStack</span>(top));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;开始出栈:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Pop_LinkedStack</span>(top,&amp;t);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;出栈后栈长为%d\n&quot;</span>,<span class="built_in">Length_LinkedStack</span>(top));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="笔试题做题技巧"><a href="#笔试题做题技巧" class="headerlink" title="笔试题做题技巧"></a>笔试题做题技巧</h3><p>（做题时牢记后进先出的特性）</p>
<ol>
<li>判断出栈合法问题</li>
</ol>
<p>入栈是降序排列：任意数A的后面比A大的数都是按照升序排列的</p>
<p>入栈是升序排列：任意数A的后面比A小的数都是按照降序排列的</p>
<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><ol>
<li><p>递归栈</p>
</li>
<li><p>用栈深度优先搜索走迷宫</p>
<p> 用栈存储路径，遇到死路弹出该路径点，然后取栈顶路径点并走没走过的路。</p>
</li>
<li><p>中后缀表达式的计算</p>
<p> 中缀表达式：就是我们平时用的标准四则运算表达式，运算符在操作数中间，例如：$9+（3-1）*3+10&#x2F;2$</p>
<p> 后缀表达式：也称为逆波兰表达式，是将运算符写在操作数之后的表达式，例如上式的后缀表达式为：$9 3 1 - 3 * + 10 2 &#x2F; +$</p>
<p> 1)<strong>中后缀转换</strong>的思路：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</p>
<p> 具体可以互联网搜索 也可以看<a target="_blank" rel="noopener" href="https://blog.csdn.net/Amentos/article/details/127182926">中后缀表达式转换及后缀表达式计算 From：CSDN</a></p>
<p> 2)<strong>后缀表达式</strong>计算思路：从左到右遍历后缀表达式的每个数字和符号，遇到数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。（具体步骤可以互联网搜索）</p>
</li>
<li><p>符号配对（如括号 冒号之类）</p>
<p>思路：遍历整个字符串过程中，遇到左符号时用栈存储，遇到右符号就和栈顶元素匹配，成功则出栈，若遍历结束后栈为空则符号配对，否则配对失败。</p>
</li>
</ol>
<h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><p>本部分参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/Jacky_Feng/article/details/108595654">CSDN: Jacky_Feng博客</a></p>
<p>队列也是操作受限的线性表，其先进先出。</p>
<h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>队列：先进先出</p>
<p>队头：允许删除的，元素出队的一端</p>
<p>队尾：允许插入的，元素入队的一端</p>
<h3 id="队列的顺序储存"><a href="#队列的顺序储存" class="headerlink" title="队列的顺序储存"></a>队列的顺序储存</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>用一组地址连续的存储单元，依次存放从队头到队尾的数据元素，称为顺序队列。</p>
<p>需要附设两个指针：队头指针（front）和队尾指针（rear），分别指向队头元素和队尾元素。</p>
<h4 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h4><ol>
<li>入队<br> 元素加入的同时队尾指针自增</li>
<li>出队<br>  取队头元素并队头指针自增</li>
</ol>
<p>以下是一个操作示意<br>  <img src="https://img-blog.csdnimg.cn/20200915114223135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2t5X0Zlbmc=,size_16,color_FFFFFF,t_70" alt="示意"></p>
<ol start="3">
<li><p>“假溢出”问题</p>
<p> 如果在插入E的基础上再插入元素F，将会插入失败。因为rear&#x3D;&#x3D;MAXSIZE，尾指针已经达到队列的最大长度。但实际上队列存储空间并未全部被占满，这种现象叫做“假溢出”</p>
</li>
</ol>
<p><strong>为了克服这个问题一般写顺序的循环队列</strong></p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>将队列的头尾相接的顺序存储结构称为循环队列。</p>
<p>示意图：<br><img src="/images/ds/image.png" alt="text"></p>
<p>问题：当循环对列为空或满时，都是队尾指针等于队头指针，即rear&#x3D;&#x3D;front 。当rear&#x3D;&#x3D;front时，该是判满还是判空呢？</p>
<p>解决方案(请根据题目给出的方案选择代码)：</p>
<p>方案一：设置一个计数器，开始时计数器设为0，新元素入队时，计数器加1，元素出队，计数器减1。当计数器&#x3D;&#x3D;MAXSIZE时，队满；计数器&#x3D;&#x3D;0时，队空。</p>
<p>方案二：保留一个元素空间，当队尾指针指的空闲单元的后继单元是队头元素所在单元时，队满。</p>
<p>队满的条件为（Q.rear+1）%MAXSIZE&#x3D;&#x3D;Q.front；</p>
<p>队空的条件为Q.rear&#x3D;&#x3D;Q.front</p>
<h4 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h4><ol>
<li>入队的改变处<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q.base[q.rear]=e;</span><br><span class="line">q.rear=(q.rear<span class="number">+1</span>)% MAXQSIZE;</span><br></pre></td></tr></table></figure></li>
<li>出队的改变处<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e=q.base[q.front];</span><br><span class="line">q.front=(q.front<span class="number">+1</span>)% MAXQSIZE;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//–––––循环队列──队列的顺序存储结构–––––</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE   100      <span class="comment">//最大队列长度</span></span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span></span><br><span class="line">&#123;QElemType * base;   <span class="comment">//初始化的动态分配存储空间</span></span><br><span class="line"> <span class="type">int</span> front;  <span class="comment">//头指针,若队列不空,指向队列头元素</span></span><br><span class="line"> <span class="type">int</span> rear;   <span class="comment">//尾指针,若队列不空,指向队列尾元素的下一个位置</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//  构造一个空队列Q</span></span><br><span class="line">  Q.base = (QElemType *)<span class="built_in">malloc</span>(MAXQSIZE * <span class="built_in">sizeof</span>(QElemType));</span><br><span class="line">  <span class="keyword">if</span> (!Q.base)  <span class="built_in">exit</span>(OVERFLOW);  <span class="comment">//存储分配失败</span></span><br><span class="line">  Q.front = <span class="number">0</span>;</span><br><span class="line">  Q.rear = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//返回Q的元素个数,即队列的长度</span></span><br><span class="line">  <span class="keyword">return</span> (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 插入元素e为Q的新的队尾元素</span></span><br><span class="line">   <span class="keyword">if</span>( (Q.rear + <span class="number">1</span>) % MAXQSIZE == Q.front )   <span class="comment">//队列满</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;                                      </span><br><span class="line">   Q.base[Q.rear]=e;</span><br><span class="line">  Q.rear = (Q.rear + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 删除队头元素，送给变量e</span></span><br><span class="line">  <span class="keyword">if</span>( Q.base[Q.front] ) <span class="keyword">return</span> ERROR;   <span class="comment">//队列空</span></span><br><span class="line">  e= Q.front;</span><br><span class="line">  (Q.front + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span>( Q.front == Q.rear ) <span class="keyword">return</span> TRUE;</span><br><span class="line">  <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列的链式储存"><a href="#队列的链式储存" class="headerlink" title="队列的链式储存"></a>队列的链式储存</h3><p>基本上和链栈的方式一样不做过多阐述直接上代码</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span>  Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//–––––队列的链式存储结构–––––</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span> <span class="title class_">QNode</span></span><br><span class="line">&#123;QElemType     data;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">QNode</span>   *next;</span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;  </span><br><span class="line">  QueuePtr front;      <span class="comment">//队头指针   </span></span><br><span class="line">  QueuePtr rear;        <span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 构造一个空队列Q</span></span><br><span class="line"> Q.front = Q.rear =(QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line"> <span class="keyword">if</span>(!Q.front) <span class="built_in">exit</span>(OVERFLOW);     <span class="comment">//存储分配失败</span></span><br><span class="line"> Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 销毁队列Q</span></span><br><span class="line"><span class="keyword">while</span>(Q.front)</span><br><span class="line"> &#123; Q.rear = Q.front-&gt;next;  </span><br><span class="line"><span class="built_in">free</span>(Q.front);</span><br><span class="line">   Q.front = Q.rear;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//返回Q的元素个数,即队列的长度</span></span><br><span class="line">  QueuePtr p;</span><br><span class="line">  <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">  p=Q.front-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(p != Q.rear)</span><br><span class="line">  &#123;</span><br><span class="line">      len++;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 插入元素e为Q的新的队尾元素</span></span><br><span class="line">  QueuePtr p;</span><br><span class="line">  p = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">  <span class="keyword">if</span>(!p)  <span class="built_in">exit</span>(OVERFLOW);        <span class="comment">//存储分配失败</span></span><br><span class="line">  p-&gt;data = e;   p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  Q.rear-&gt;next=p;  </span><br><span class="line">    Q.rear =p;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//若队列不空,则删除Q的队头元素,用e返回其值,</span></span><br><span class="line"><span class="comment">//并返回OK;  否则返回ERROR</span></span><br><span class="line">  QueuePtr p;</span><br><span class="line">  <span class="keyword">if</span>( Q.front==Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">  p = Q.front-&gt;next; </span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">  </span><br><span class="line">Q.front-&gt;next=p-&gt;next;</span><br><span class="line">  <span class="keyword">if</span>(Q.rear==p)Q.rear = Q.front;</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> TRUE;</span><br><span class="line">  <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h2><p>课内只讲述了定义和类型实现,</p>
<p>请阅读此篇博客来解决问题（注：空格串即空白串）<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Real_Fool_/article/details/113877781">数据结构：串(String)【详解】</a></p>
<h2 id="数组和广义表（Array-and-Table）"><a href="#数组和广义表（Array-and-Table）" class="headerlink" title="数组和广义表（Array and Table）"></a>数组和广义表（Array and Table）</h2><p>此内容个人认为ppt讲述较为完善，请查看课内ppt附件。</p>
<p>数据的学习目标大概为:</p>
<ol>
<li>会计算按行、按列、按页优先顺序存放的数组元素a[i][j][k]的存储地址。解决ppt习题。</li>
<li>特殊矩阵的定义，其压缩存储办法和储存地址的计算方法。解决ppt后习题。</li>
<li>广义表的定义和画图表示</li>
</ol>
<h2 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h2><p>施工中</p>
<p><img src="https://blog.csdn.net/Real_Fool_/article/details/113930623" alt="数据结构：树(Tree)【详解】 From CSDN "></p>
<h3 id="基本定义及术语"><a href="#基本定义及术语" class="headerlink" title="基本定义及术语"></a>基本定义及术语</h3><ol>
<li>定义<br>树是n（n&gt;&#x3D;0）个结点的有限集。</li>
</ol>
<p>当n &#x3D; 0时，称为空树。在任意一棵非空树中应满足：有且仅有一个特定的称为根的结点。</p>
<p>当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集T1,T2,…,Tm，其中每个集合本身又是一棵树，并且称为根的子树。</p>
<p>显然，树的定义是递归的，即在树的定义中又用到了自身，树是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：</p>
<p>树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。树中所有结点可以有零个或多个后继。</p>
<p>因此n个结点的树中有n-1条边。<br>2. 术语</p>
<p>结合实例理解树的术语 </p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h3 id="遍历二叉树和线索二叉树"><a href="#遍历二叉树和线索二叉树" class="headerlink" title="遍历二叉树和线索二叉树"></a>遍历二叉树和线索二叉树</h3><p>pta答案补充</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//非递归中序遍历算法。</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T,Status(*Visit)(BiTree e))</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//采用二叉链表存储结构</span></span><br><span class="line">   <span class="comment">//中序历遍二叉树T的非递归算法，对每个数据元素调用函数Visit。</span></span><br><span class="line"> SqStack S;</span><br><span class="line"> BiTree p;</span><br><span class="line"> <span class="built_in">InitStack</span>(S);</span><br><span class="line"> p=T;</span><br><span class="line"> <span class="keyword">while</span>(p || !<span class="built_in">StackEmpty</span>(S) )</span><br><span class="line"> &#123;  <span class="keyword">if</span>(p)</span><br><span class="line">       &#123;<span class="built_in">Push</span>(S,p);p=p-&gt;lchild; &#125;   <span class="comment">//根指针进栈, 历遍左子树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="built_in">Pop</span>(S,p);   <span class="comment">//根指针退栈，访问结点，历遍右子树</span></span><br><span class="line">          (*Visit)(p);</span><br><span class="line">         p=p-&gt;rchild;</span><br><span class="line">        &#125;<span class="comment">//else</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><h3 id="赫夫曼树及应用（编码）"><a href="#赫夫曼树及应用（编码）" class="headerlink" title="赫夫曼树及应用（编码）"></a>赫夫曼树及应用（编码）</h3><h2 id="图（Graph）"><a href="#图（Graph）" class="headerlink" title="图（Graph）"></a>图（Graph）</h2><p>施工中</p>
<p><img src="https://blog.csdn.net/Real_Fool_/article/details/114141377" alt="数据结构 图（Group【详解】 From CSDN"></p>
<h3 id="图的定义及术语"><a href="#图的定义及术语" class="headerlink" title="图的定义及术语"></a>图的定义及术语</h3><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="邻接表和邻接矩阵"><a href="#邻接表和邻接矩阵" class="headerlink" title="邻接表和邻接矩阵"></a>邻接表和邻接矩阵</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无向图采用邻接矩阵结构存储，本题要求实现无向图的基本操作，请填空。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的数组(邻接矩阵)存储表示</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20 <span class="comment">// 最大顶点个数</span></span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">GraphKind</span>&#123;DG,DN,AG,AN&#125;; <span class="comment">// &#123;有向图,有向网,无向图,无向网&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点关系类型。对无权图，用1(是)或0(否)表示相邻否； 对带权图，则为权值类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MGraph</span></span><br><span class="line">&#123;</span><br><span class="line">  VertexType vexs[MAX_VERTEX_NUM]; <span class="comment">// 顶点向量</span></span><br><span class="line">  AdjMatrix arcs; <span class="comment">// 邻接矩阵</span></span><br><span class="line">  <span class="type">int</span> vexnum,arcnum; <span class="comment">// 图的当前顶点数和弧数</span></span><br><span class="line">  GraphKind kind; <span class="comment">// 图的种类标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的数组(邻接矩阵)存储基本操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateVex</span><span class="params">(MGraph G,VertexType u)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 初始条件:图G存在,u和G中顶点有相同特征</span></span><br><span class="line">  <span class="comment">// 操作结果:若G中存在顶点u,则返回该顶点在图中位置;否则返回-1</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(G.vexs[i], u) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateAG</span><span class="params">(MGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 采用数组(邻接矩阵)表示法,由文件构造没有相关信息的无向图G</span></span><br><span class="line">  <span class="type">int</span> i,j,k;</span><br><span class="line">  VertexType va,vb;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入无向图G的顶点数,边数:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;G.vexnum);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;G.arcnum);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n请输入%d个顶点的值:\n&quot;</span>,G.vexnum);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i) <span class="comment">// 构造顶点向量</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot; %s&quot;</span>, G.vexs[i]);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i) <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;++j)</span><br><span class="line">      G.arcs[i][j]=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入%d条边的顶点1 顶点2:\n&quot;</span>,G.arcnum);</span><br><span class="line">  <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.arcnum;++k)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot; %s%s&quot;</span>,va,vb);</span><br><span class="line">    i=<span class="built_in">LocateVex</span>(G, va);</span><br><span class="line">    j=<span class="built_in">LocateVex</span>(G, vb);</span><br><span class="line">    G.arcs[i][j]=G.arcs[j][i]=<span class="number">1</span>; <span class="comment">// 无向图</span></span><br><span class="line">  &#125;</span><br><span class="line">  G.kind=AG;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyGraph</span><span class="params">(MGraph &amp;G)</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">// 初始条件: 图G存在。操作结果: 销毁无向图G</span></span><br><span class="line">   G.vexnum=<span class="number">0</span>;</span><br><span class="line">   G.arcnum=<span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">PutVex</span><span class="params">(MGraph &amp;G,VertexType v,VertexType value)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 初始条件: 图G存在，v是G中某个顶点。操作结果: 对v赋新值value</span></span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  k=_LocateVex(G, v); <span class="comment">// k为顶点v在图G中的序号</span></span><br><span class="line">  <span class="keyword">if</span>(k&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="built_in">strcpy</span>(G.vexs[k], value);</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FirstAdjVex</span><span class="params">(MGraph G,VertexType v)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 初始条件: 图G存在,v是G中某个顶点</span></span><br><span class="line">  <span class="comment">// 操作结果: 返回v的第一个邻接顶点的序号。若顶点在G中没有邻接顶点,则返回-1</span></span><br><span class="line">  <span class="type">int</span> i,j=<span class="number">0</span>,k;</span><br><span class="line">  k=<span class="built_in">LocateVex</span>(G, v); <span class="comment">// k为顶点v在图G中的序号</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    <span class="keyword">if</span>(G.arcs[i][k] == <span class="number">1</span>)   <span class="comment">//无向图</span></span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NextAdjVex</span><span class="params">(MGraph G,VertexType v,VertexType w)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 初始条件: 图G存在,v是G中某个顶点,w是v的邻接顶点</span></span><br><span class="line">  <span class="comment">// 操作结果: 返回v的(相对于w的)下一个邻接顶点的序号,</span></span><br><span class="line">  <span class="comment">//           若w是v的最后一个邻接顶点,则返回-1</span></span><br><span class="line">  <span class="type">int</span> i,j=<span class="number">0</span>,k1,k2;</span><br><span class="line">  k1=<span class="built_in">LocateVex</span>(G, v); <span class="comment">// k1为顶点v在图G中的序号</span></span><br><span class="line">  k2=<span class="built_in">LocateVex</span>(G, w); <span class="comment">// k2为顶点w在图G中的序号</span></span><br><span class="line">  <span class="keyword">for</span>(i=k2<span class="number">+1</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    <span class="keyword">if</span>(G.arcs[i][k1] == <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertVex</span><span class="params">(MGraph &amp;G,VertexType v)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 初始条件: 图G存在,v和图G中顶点有相同特征</span></span><br><span class="line">  <span class="comment">// 操作结果: 在图G中增添新顶点v(不增添与顶点相关的弧,留待InsertArc()去做)</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">strcpy</span>(G.vexs[G.vexnum],v); <span class="comment">// 构造新顶点向量</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=G.vexnum;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    G.arcs[G.vexnum][i]=<span class="number">0</span>; <span class="comment">// 初始化该行邻接矩阵的值(无边或弧)</span></span><br><span class="line">    G.arcs[i][G.vexnum]=<span class="number">0</span>; <span class="comment">// 初始化该列邻接矩阵的值(无边或弧)</span></span><br><span class="line">  &#125;</span><br><span class="line">G.vexnum++; <span class="comment">// 图G的顶点数加1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeleteVex</span><span class="params">(MGraph &amp;G,VertexType v)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 初始条件: 图G存在,v是G中某个顶点。操作结果: 删除G中顶点v及其相关的弧</span></span><br><span class="line">  <span class="type">int</span> i,j,k;</span><br><span class="line">  k=<span class="built_in">LocateVex</span>(G,v); <span class="comment">// k为待删除顶点v的序号</span></span><br><span class="line">  <span class="keyword">if</span>(k&lt;<span class="number">0</span>) <span class="comment">// v不是图G的顶点</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">    <span class="keyword">if</span>(G.arcs[j][k]!=<span class="number">0</span>) <span class="comment">// 有边</span></span><br><span class="line">      G.arcnum--; <span class="comment">// 修改边数</span></span><br><span class="line">  <span class="keyword">for</span>(j=k<span class="number">+1</span>;j&lt;G.vexnum;j++) <span class="comment">// 序号k后面的顶点向量依次前移</span></span><br><span class="line">    <span class="built_in">strcpy</span>(G.vexs[j<span class="number">-1</span>], G.vexs[j]);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    <span class="keyword">for</span>(j=k<span class="number">+1</span>;j&lt;G.vexnum;j++)</span><br><span class="line">      G.arcs[i][j<span class="number">-1</span>]=G.arcs[i][j]; <span class="comment">// 移动待删除顶点之后的矩阵元素</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    <span class="keyword">for</span>(j=k<span class="number">+1</span>;j&lt;G.vexnum;j++)</span><br><span class="line">      G.arcs[j<span class="number">-1</span>][i]=G.arcs[j][i]; <span class="comment">// 移动待删除顶点之下的矩阵元素</span></span><br><span class="line">  G.vexnum--; <span class="comment">// 更新图的顶点数</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InsertArc</span><span class="params">(MGraph &amp;G,VertexType v,VertexType w)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 初始条件: 图G存在,v和W是G中两个顶点</span></span><br><span class="line">  <span class="comment">// 操作结果: 在G中增添弧&lt;v,w&gt;,若G是无向的,则还增添对称弧&lt;w,v&gt;</span></span><br><span class="line">  <span class="type">int</span> i,l,v1,w1;</span><br><span class="line">  v1=<span class="built_in">LocateVex</span>(G, v); <span class="comment">// 尾</span></span><br><span class="line">  w1=<span class="built_in">LocateVex</span>(G, w); <span class="comment">// 头</span></span><br><span class="line">  <span class="keyword">if</span>(v1&lt;<span class="number">0</span>||w1&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  G.arcnum++; <span class="comment">// 弧或边数加1</span></span><br><span class="line">  G.arcs[v1][w1] = G.arcs[w1][v1] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeleteArc</span><span class="params">(MGraph &amp;G,VertexType v,VertexType w)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 初始条件: 图G存在,v和w是G中两个顶点</span></span><br><span class="line">  <span class="comment">// 操作结果: 在G中删除弧&lt;v,w&gt;,若G是无向的,则还删除对称弧&lt;w,v&gt;</span></span><br><span class="line">  <span class="type">int</span> v1,w1;</span><br><span class="line">  v1=<span class="built_in">LocateVex</span>(G, v); <span class="comment">// 尾</span></span><br><span class="line">  w1=<span class="built_in">LocateVex</span>(G, w); <span class="comment">// 头</span></span><br><span class="line">  <span class="keyword">if</span>(v1&lt;<span class="number">0</span>||w1&lt;<span class="number">0</span>) <span class="comment">// v1、w1的值不合法</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  G.arcs[v1][w1] = G.arcs[w1][v1]=<span class="number">0</span>;</span><br><span class="line">  G.arcnum--;    <span class="comment">//修改边数</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">(MGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 输出无向图G</span></span><br><span class="line">  <span class="type">int</span> i,j;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d个顶点%d条边的无向图\n&quot;</span>,G.vexnum,G.arcnum);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i) <span class="comment">// 输出G.vexs</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;G.vexs[%d]=%s\n&quot;</span>,i,G.vexs[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;G.arcs:\n&quot;</span>); <span class="comment">// 输出G.arcs.adj</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,G.arcs[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i,j,k,n;</span><br><span class="line">  VertexType v1,v2;</span><br><span class="line">  MGraph g;</span><br><span class="line">  <span class="built_in">CreateAG</span>(g);</span><br><span class="line">  <span class="built_in">Display</span>(g);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;修改顶点的值，请输入原值 新值: \n&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,v1,v2);</span><br><span class="line">  <span class="built_in">PutVex</span>(g,v1,v2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;删除一条边或弧，请输入待删除边或弧的弧尾 弧头：\n&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,v1,v2);</span><br><span class="line">  <span class="built_in">DeleteArc</span>(g,v1,v2);</span><br><span class="line">  <span class="built_in">Display</span>(g);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;插入新顶点，请输入顶点的值: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,v1);</span><br><span class="line">  <span class="built_in">InsertVex</span>(g,v1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n插入与新顶点有关的边，请输入边数: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n请输入另一顶点的值: &quot;</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,v2);</span><br><span class="line">      <span class="built_in">InsertArc</span>(g,v1,v2);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">Display</span>(g);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;删除顶点及相关边，请输入顶点的值: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,v1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">DeleteVex</span>(g,v1);</span><br><span class="line">  <span class="built_in">Display</span>(g);</span><br><span class="line">  <span class="built_in">DestroyGraph</span>(g);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span>  Status;</span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 30 <span class="comment">// 最大顶点个数</span></span></span><br><span class="line"> <span class="keyword">enum</span> <span class="title class_">GraphKind</span>&#123;DG,DN,AG,AN&#125;; <span class="comment">// &#123;有向图,有向网,无向图,无向网&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//图的邻接表存储表示</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">char</span> VertexType[<span class="number">6</span>];</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">ArcNode</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="type">int</span> adjvex; <span class="comment">// 该弧所指向的顶点的位置</span></span><br><span class="line">   ArcNode *nextarc; <span class="comment">// 指向下一条弧的指针</span></span><br><span class="line">   <span class="type">int</span> info; <span class="comment">// 网的权值</span></span><br><span class="line"> &#125;; <span class="comment">// 表结点</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line"> &#123;</span><br><span class="line">   VertexType data; <span class="comment">// 顶点信息</span></span><br><span class="line">   ArcNode *firstarc; <span class="comment">// 第一个表结点的地址,指向第一条依附该顶点的弧的指针</span></span><br><span class="line"> &#125;VNode,AdjList[MAX_VERTEX_NUM]; <span class="comment">// 头结点</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">ALGraph</span></span><br><span class="line"> &#123;</span><br><span class="line">   AdjList vertices;</span><br><span class="line">   <span class="type">int</span> vexnum,arcnum; <span class="comment">// 图的当前顶点数和弧数</span></span><br><span class="line">   <span class="type">int</span> kind; <span class="comment">// 图的种类标志</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">LocateVex</span><span class="params">(ALGraph G,VertexType u)</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">// 初始条件: 图G存在,u和G中顶点有相同特征</span></span><br><span class="line">   <span class="comment">// 操作结果: 若G中存在顶点u,则返回该顶点在图中位置;否则返回-1</span></span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">strcmp</span>(G.vertices[i].data, u) == <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> i;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">Status <span class="title">CreateGraph</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">//采用头插法,构造有向网</span></span><br><span class="line">   <span class="type">int</span> i,j,k;</span><br><span class="line">   <span class="type">int</span> w; <span class="comment">// 权值</span></span><br><span class="line">   VertexType va,vb;</span><br><span class="line">   ArcNode *p;</span><br><span class="line">   G.kind=DN;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;请输入图的顶点数,弧数: &quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;G.vexnum, &amp;G.arcnum);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n请输入%d个顶点的值:\n&quot;</span>,G.vexnum);</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i) <span class="comment">// 构造顶点向量</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,G.vertices[i].data);</span><br><span class="line">     G.vertices[i].firstarc=<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;请依次输入每条弧弧尾和弧头、权值(以空格作为间隔):\n&quot;</span>);</span><br><span class="line">   <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.arcnum;++k) <span class="comment">// 构造表结点链表</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%s%s%d&quot;</span>,va,vb,&amp;w);</span><br><span class="line">     i=<span class="built_in">LocateVex</span>(G, va); <span class="comment">// 弧尾</span></span><br><span class="line">     j=<span class="built_in">LocateVex</span>(G, vb); <span class="comment">// 弧头</span></span><br><span class="line">     p=(ArcNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ArcNode));</span><br><span class="line">     p-&gt;adjvex=j;</span><br><span class="line">     p-&gt;info=w;</span><br><span class="line">     p-&gt;nextarc=G.vertices[i].firstarc; <span class="comment">// 插在表头</span></span><br><span class="line">     G.vertices[i].firstarc=p;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">DestroyGraph</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">// 初始条件: 图G存在。操作结果: 销毁图G</span></span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   ArcNode *p,*q;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">   &#123;</span><br><span class="line">     p=G.vertices[i].firstarc;</span><br><span class="line">     <span class="keyword">while</span>(p)</span><br><span class="line">     &#123;</span><br><span class="line">       q=p-&gt;nextarc;</span><br><span class="line">       <span class="built_in">free</span>(p);</span><br><span class="line">       p=q;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     G.vexnum=<span class="number">0</span>;</span><br><span class="line">   G.arcnum=<span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">PutVex</span><span class="params">(ALGraph &amp;G,VertexType v,VertexType value)</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">// 初始条件: 图G存在,v是G中某个顶点</span></span><br><span class="line">   <span class="comment">// 操作结果: 对v赋新值value</span></span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   i=<span class="built_in">LocateVex</span>(G, v);</span><br><span class="line">   <span class="keyword">if</span>(i&gt;<span class="number">-1</span>) <span class="comment">// v是G的顶点</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>(G.vertices[i].data, value);</span><br><span class="line">     <span class="keyword">return</span> OK;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ERROR;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">FirstAdjVex</span><span class="params">(ALGraph G,VertexType v)</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">// 初始条件: 图G存在,v是G中某个顶点</span></span><br><span class="line">   <span class="comment">// 操作结果: 返回v的第一个邻接顶点的序号。若顶点在G中没有邻接顶点,则返回-1</span></span><br><span class="line">   ArcNode *p;</span><br><span class="line">   <span class="type">int</span> v1;</span><br><span class="line">   v1=<span class="built_in">LocateVex</span>(G, v); <span class="comment">// v1为顶点v在图G中的序号</span></span><br><span class="line">   p=G.vertices[v1].firstarc;</span><br><span class="line">   <span class="keyword">if</span>(p)</span><br><span class="line">     <span class="keyword">return</span> ____16____;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">NextAdjVex</span><span class="params">(ALGraph G,VertexType v,VertexType w)</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">// 初始条件: 图G存在,v是G中某个顶点,w是v的邻接顶点</span></span><br><span class="line">   <span class="comment">// 操作结果: 返回v的(相对于w的)下一个邻接顶点的序号。</span></span><br><span class="line">   <span class="comment">//           若w是v的最后一个邻接点,则返回-1</span></span><br><span class="line">   ArcNode *p;</span><br><span class="line">   <span class="type">int</span> v1,w1;</span><br><span class="line">   v1=____17____; <span class="comment">// v1为顶点v在图G中的序号</span></span><br><span class="line">   w1=____18____; <span class="comment">// w1为顶点w在图G中的序号</span></span><br><span class="line">   p=G.vertices[v1].firstarc;</span><br><span class="line">   <span class="keyword">while</span>(____19____) <span class="comment">// 指针p不空且所指表结点不是w</span></span><br><span class="line">     p=p-&gt;nextarc;</span><br><span class="line">   <span class="keyword">if</span>(!p||!p-&gt;nextarc) <span class="comment">// 没找到w或w是最后一个邻接点</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">return</span> ____20____; <span class="comment">// 返回v的(相对于w的)下一个邻接顶点的序号</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">InsertVex</span><span class="params">(ALGraph &amp;G,VertexType v)</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">// 初始条件: 图G存在,v和图中顶点有相同特征</span></span><br><span class="line">   <span class="comment">// 操作结果: 在图G中增添新顶点v(不增添与顶点相关的弧,留待InsertArc()去做)</span></span><br><span class="line">   <span class="built_in">strcpy</span>(G.vertices[G.vexnum].data,v); <span class="comment">// 构造新顶点向量</span></span><br><span class="line">   ____21____;</span><br><span class="line">   ____22____; <span class="comment">// 图G的顶点数加1</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">Status <span class="title">DeleteVex</span><span class="params">(ALGraph &amp;G,VertexType v)</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">// 初始条件: 图G存在,v是G中某个顶点</span></span><br><span class="line">   <span class="comment">// 操作结果: 删除G中顶点v及其相关的弧</span></span><br><span class="line">   <span class="type">int</span> i,j;</span><br><span class="line">   ArcNode *p,*q;</span><br><span class="line">   j=____23____; <span class="comment">// j是顶点v的序号</span></span><br><span class="line">   <span class="keyword">if</span>(j&lt;<span class="number">0</span>) <span class="comment">// v不是图G的顶点</span></span><br><span class="line">     <span class="keyword">return</span> ERROR;</span><br><span class="line">   p=____24____; <span class="comment">// 删除以v为出度的弧</span></span><br><span class="line">   <span class="keyword">while</span>(p)</span><br><span class="line">   &#123;</span><br><span class="line">     ____25____;</span><br><span class="line">     p=p-&gt;nextarc;</span><br><span class="line">     <span class="built_in">free</span>(q);</span><br><span class="line">     ____26____; <span class="comment">// 弧或边数减1</span></span><br><span class="line">   &#125;</span><br><span class="line">   ____27____; <span class="comment">// 顶点数减1</span></span><br><span class="line">   <span class="keyword">for</span>(____28____;i&lt;G.vexnum;i++) <span class="comment">// 顶点v后面的顶点前移</span></span><br><span class="line">     G.vertices[i]=G.vertices[i<span class="number">+1</span>];</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++) <span class="comment">// 删除以v为入度的弧且必要时修改表结点的顶点位置值</span></span><br><span class="line">   &#123;</span><br><span class="line">     p=G.vertices[i].firstarc; <span class="comment">// 指向第1条弧</span></span><br><span class="line">     <span class="keyword">while</span>(p) <span class="comment">// 有弧</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">if</span>(p-&gt;adjvex==j)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span>(p==G.vertices[i].firstarc) <span class="comment">// 待删结点是第1个结点</span></span><br><span class="line">         &#123;</span><br><span class="line">           ____29____;</span><br><span class="line">           <span class="built_in">free</span>(p);</span><br><span class="line">           p=____30____;</span><br><span class="line">           G.arcnum--; <span class="comment">// 弧数减1</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">          ____31____;</span><br><span class="line">           <span class="built_in">free</span>(p);</span><br><span class="line">           p=____32____;</span><br><span class="line">           G.arcnum--; <span class="comment">// 弧减1</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span>(____33____)</span><br><span class="line">           p-&gt;adjvex--; <span class="comment">// 修改表结点的顶点位置值(序号)</span></span><br><span class="line">         q=p;</span><br><span class="line">         p=p-&gt;nextarc;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">Status <span class="title">InsertArc</span><span class="params">(ALGraph &amp;G,VertexType v,VertexType w)</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">// 初始条件: 图G存在,v和w是G中两个顶点</span></span><br><span class="line">   <span class="comment">// 操作结果: 在G中增添弧&lt;v,w&gt;</span></span><br><span class="line">   ArcNode *p;</span><br><span class="line">   <span class="type">int</span> w1,i,j;</span><br><span class="line">   i=____34____; <span class="comment">// 弧尾的序号</span></span><br><span class="line">   j=____35____; <span class="comment">// 弧头的序号</span></span><br><span class="line">   <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> ERROR;</span><br><span class="line">   G.arcnum++; <span class="comment">// 图G的弧或边的数目加1</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n请输入弧%s→%s的权值: &quot;</span>,v,w);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w1);</span><br><span class="line">   p=(ArcNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ArcNode));</span><br><span class="line">   p-&gt;adjvex=____36____;</span><br><span class="line">   p-&gt;info=____37____;</span><br><span class="line">   p-&gt;nextarc=____38____; <span class="comment">// 插在表头</span></span><br><span class="line">   G.vertices[i].firstarc=____39____;</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">Status <span class="title">DeleteArc</span><span class="params">(ALGraph &amp;G,VertexType v,VertexType w)</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">// 初始条件: 图G存在,v和w是G中两个顶点</span></span><br><span class="line">   <span class="comment">// 操作结果: 在G中删除弧&lt;v,w&gt;</span></span><br><span class="line">   ArcNode *p,*q;</span><br><span class="line">   <span class="type">int</span> i,j;</span><br><span class="line">   i=____40____; <span class="comment">// i是顶点v(弧尾)的序号</span></span><br><span class="line">   j=____41____; <span class="comment">// j是顶点w(弧头)的序号</span></span><br><span class="line">   <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i==j)</span><br><span class="line">     <span class="keyword">return</span> ERROR;</span><br><span class="line">   p=G.vertices[i].firstarc; <span class="comment">// p指向顶点v的第一条出弧</span></span><br><span class="line">   <span class="keyword">while</span>(____42____) <span class="comment">// p不空且所指之弧不是待删除弧&lt;v,w&gt;</span></span><br><span class="line">   &#123; <span class="comment">// p指向下一条弧</span></span><br><span class="line">     q=p;</span><br><span class="line">     p=p-&gt;nextarc;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(____43____) <span class="comment">// 找到弧&lt;v,w&gt;</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span>(p==G.vertices[i].firstarc) <span class="comment">// p所指是第1条弧</span></span><br><span class="line">       ____44____; <span class="comment">// 指向下一条弧</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       ____45____; <span class="comment">// 指向下一条弧</span></span><br><span class="line">     <span class="built_in">free</span>(p); <span class="comment">// 释放此结点</span></span><br><span class="line">     G.arcnum--; <span class="comment">// 弧或边数减1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">(ALGraph G)</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">// 输出图的邻接矩阵G</span></span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   ArcNode *p;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d个顶点：\n&quot;</span>,G.vexnum);</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,G.vertices[i].data);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n%d条弧:\n&quot;</span>,G.arcnum);</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">   &#123;</span><br><span class="line">     p=G.vertices[i].firstarc;</span><br><span class="line">     <span class="keyword">while</span>(p)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s→%s &quot;</span>,G.vertices[i].data,G.vertices[p-&gt;adjvex].data);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;:%d &quot;</span>,p-&gt;info);</span><br><span class="line">        p=p-&gt;nextarc;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="type">int</span> i,j,k,n;</span><br><span class="line">   ALGraph g;</span><br><span class="line">   VertexType v1,v2;</span><br><span class="line">   <span class="built_in">CreateGraph</span>(g);</span><br><span class="line">   <span class="built_in">Display</span>(g);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;删除一条弧，请输入待删除弧的弧尾 弧头：&quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot; %s%s&quot;</span>,v1,v2);</span><br><span class="line">   <span class="built_in">DeleteArc</span>(g,v1,v2);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n修改顶点的值，请输入原值 新值: &quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot; %s%s&quot;</span>,v1,v2);</span><br><span class="line">   <span class="built_in">PutVex</span>(g,v1,v2);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n插入新顶点，请输入顶点的值: &quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,v1);</span><br><span class="line">   <span class="built_in">InsertVex</span>(g,v1);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n插入与新顶点有关的弧，请输入弧数: &quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">   <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\n请输入另一顶点的值: &quot;</span>);</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,v2);</span><br><span class="line">     <span class="built_in">InsertArc</span>(g,v2,v1);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="built_in">Display</span>(g);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;删除顶点及相关的弧，请输入顶点的值: &quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,v1);</span><br><span class="line">   <span class="built_in">DeleteVex</span>(g,v1);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="built_in">Display</span>(g);</span><br><span class="line">   <span class="built_in">DestroyGraph</span>(g);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="深度优先和广度优先"><a href="#深度优先和广度优先" class="headerlink" title="深度优先和广度优先"></a>深度优先和广度优先</h4><h3 id="联通问题"><a href="#联通问题" class="headerlink" title="联通问题"></a>联通问题</h3><h4 id="深度、广度生成树、森林（不联通）"><a href="#深度、广度生成树、森林（不联通）" class="headerlink" title="深度、广度生成树、森林（不联通）"></a>深度、广度生成树、森林（不联通）</h4><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><h5 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h5><h5 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h5><h3 id="有向无环图及其应用（拓扑排列、关键路径）"><a href="#有向无环图及其应用（拓扑排列、关键路径）" class="headerlink" title="有向无环图及其应用（拓扑排列、关键路径）"></a>有向无环图及其应用（拓扑排列、关键路径）</h3><h3 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h3><h4 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h4><h4 id="多源最短路"><a href="#多源最短路" class="headerlink" title="多源最短路"></a>多源最短路</h4><h2 id="查找（Search）"><a href="#查找（Search）" class="headerlink" title="查找（Search）"></a>查找（Search）</h2><p>重点：求查找成功和失败的ASL（平均查找长度）</p>
<h3 id="有序表的查找"><a href="#有序表的查找" class="headerlink" title="有序表的查找"></a>有序表的查找</h3><h4 id="哨兵遍历"><a href="#哨兵遍历" class="headerlink" title="哨兵遍历"></a>哨兵遍历</h4><h4 id="折半二分查找"><a href="#折半二分查找" class="headerlink" title="折半二分查找"></a>折半二分查找</h4><h3 id="二叉排序树和平衡二叉树"><a href="#二叉排序树和平衡二叉树" class="headerlink" title="二叉排序树和平衡二叉树"></a>二叉排序树和平衡二叉树</h3><h3 id="B-tree和B-树"><a href="#B-tree和B-树" class="headerlink" title="B-tree和B+树"></a>B-tree和B+树</h3><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h2 id="内部排序（Sort）"><a href="#内部排序（Sort）" class="headerlink" title="内部排序（Sort）"></a>内部排序（Sort）</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="插入排序-1"><a href="#插入排序-1" class="headerlink" title="插入排序"></a>插入排序</h4><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="选择排序-1"><a href="#选择排序-1" class="headerlink" title="选择排序"></a>选择排序</h4><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h3 id="桶（基数）排序"><a href="#桶（基数）排序" class="headerlink" title="桶（基数）排序"></a>桶（基数）排序</h3><h1 id="可能出简答题的比较难的知识点"><a href="#可能出简答题的比较难的知识点" class="headerlink" title="可能出简答题的比较难的知识点"></a>可能出简答题的比较难的知识点</h1><h2 id="二叉树和树转换"><a href="#二叉树和树转换" class="headerlink" title="二叉树和树转换"></a>二叉树和树转换</h2><p>把所有的兄弟节点连虚线，保留第一个连线，把其他的连线去掉，转换。</p>
<h2 id="B-tree的构建"><a href="#B-tree的构建" class="headerlink" title="B-tree的构建"></a>B-tree的构建</h2><h2 id="哈夫曼树及哈夫曼编码"><a href="#哈夫曼树及哈夫曼编码" class="headerlink" title="哈夫曼树及哈夫曼编码"></a>哈夫曼树及哈夫曼编码</h2><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><h2 id="dijisktra"><a href="#dijisktra" class="headerlink" title="dijisktra"></a>dijisktra</h2><h2 id="prim-1"><a href="#prim-1" class="headerlink" title="prim"></a>prim</h2><h2 id="kruskal-1"><a href="#kruskal-1" class="headerlink" title="kruskal"></a>kruskal</h2><h2 id="哈希表求ASL"><a href="#哈希表求ASL" class="headerlink" title="哈希表求ASL"></a>哈希表求ASL</h2><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><h2 id="堆排"><a href="#堆排" class="headerlink" title="堆排"></a>堆排</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://AngelicaDahuric.github.io">白芷</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://angelicadahuric.github.io/2023/ds/">https://angelicadahuric.github.io/2023/ds/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://AngelicaDahuric.github.io" target="_blank">白芷小姐の陋室</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/dp/" title="区间dp学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">区间dp学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">白芷</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E8%A7%88"><span class="toc-number">1.</span> <span class="toc-text">总览</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88LinkList%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">线性表（LinkList）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">逻辑结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%EF%BC%88SeqList%EF%BC%89"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">顺序表（SeqList）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.2.1.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%EF%BC%88Link-List%EF%BC%89"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">链表（Link List）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.2.2.3.</span> <span class="toc-text">一些概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.2.4.</span> <span class="toc-text">操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.2.2.5.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%EF%BC%88Stack%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">栈（Stack）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">1.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">栈的顺序储存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">栈的顺序储存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%93%8D%E4%BD%9C%E5%8F%8A%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">栈的操作及代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">栈的链式储存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%82%A8%E5%AD%98"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">栈的链式储存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%94%E8%AF%95%E9%A2%98%E5%81%9A%E9%A2%98%E6%8A%80%E5%B7%A7"><span class="toc-number">1.2.4.</span> <span class="toc-text">笔试题做题技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.5.</span> <span class="toc-text">栈的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">队列（Queue）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="toc-number">1.3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98"><span class="toc-number">1.3.2.</span> <span class="toc-text">队列的顺序储存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-4"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.3.3.</span> <span class="toc-text">循环队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-5"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C-3"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%82%A8%E5%AD%98"><span class="toc-number">1.3.4.</span> <span class="toc-text">队列的链式储存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">字符串（String）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8%EF%BC%88Array-and-Table%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">数组和广义表（Array and Table）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%EF%BC%88Tree%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">树（Tree）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.6.1.</span> <span class="toc-text">基本定义及术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.6.2.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.6.3.</span> <span class="toc-text">遍历二叉树和线索二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="toc-number">1.6.4.</span> <span class="toc-text">树和森林</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%BA%94%E7%94%A8%EF%BC%88%E7%BC%96%E7%A0%81%EF%BC%89"><span class="toc-number">1.6.5.</span> <span class="toc-text">赫夫曼树及应用（编码）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%EF%BC%88Graph%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">图（Graph）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.7.1.</span> <span class="toc-text">图的定义及术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.2.</span> <span class="toc-text">存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%92%8C%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">邻接表和邻接矩阵</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.3.</span> <span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">深度优先和广度优先</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E9%80%9A%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.4.</span> <span class="toc-text">联通问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E3%80%81%E5%B9%BF%E5%BA%A6%E7%94%9F%E6%88%90%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%EF%BC%88%E4%B8%8D%E8%81%94%E9%80%9A%EF%BC%89"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">深度、广度生成树、森林（不联通）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#prim"><span class="toc-number">1.7.4.2.1.</span> <span class="toc-text">prim</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#kruskal"><span class="toc-number">1.7.4.2.2.</span> <span class="toc-text">kruskal</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%EF%BC%88%E6%8B%93%E6%89%91%E6%8E%92%E5%88%97%E3%80%81%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%EF%BC%89"><span class="toc-number">1.7.5.</span> <span class="toc-text">有向无环图及其应用（拓扑排列、关键路径）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.6.</span> <span class="toc-text">最短路径问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.7.6.1.</span> <span class="toc-text">单源最短路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.7.6.2.</span> <span class="toc-text">多源最短路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%EF%BC%88Search%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">查找（Search）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">1.8.1.</span> <span class="toc-text">有序表的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E9%81%8D%E5%8E%86"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">哨兵遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">折半二分查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%92%8C%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.8.2.</span> <span class="toc-text">二叉排序树和平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-tree%E5%92%8CB-%E6%A0%91"><span class="toc-number">1.8.3.</span> <span class="toc-text">B-tree和B+树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.8.4.</span> <span class="toc-text">哈希表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%EF%BC%88Sort%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">内部排序（Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.9.1.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-1"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">希尔排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">1.9.2.</span> <span class="toc-text">交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.9.3.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.9.4.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-1"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">堆排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%B6%EF%BC%88%E5%9F%BA%E6%95%B0%EF%BC%89%E6%8E%92%E5%BA%8F"><span class="toc-number">1.9.5.</span> <span class="toc-text">桶（基数）排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E5%87%BA%E7%AE%80%E7%AD%94%E9%A2%98%E7%9A%84%E6%AF%94%E8%BE%83%E9%9A%BE%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">可能出简答题的比较难的知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%A0%91%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.</span> <span class="toc-text">二叉树和树转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-tree%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">2.2.</span> <span class="toc-text">B-tree的构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">2.3.</span> <span class="toc-text">哈夫曼树及哈夫曼编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">2.5.</span> <span class="toc-text">关键路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dijisktra"><span class="toc-number">2.6.</span> <span class="toc-text">dijisktra</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prim-1"><span class="toc-number">2.7.</span> <span class="toc-text">prim</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kruskal-1"><span class="toc-number">2.8.</span> <span class="toc-text">kruskal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E6%B1%82ASL"><span class="toc-number">2.9.</span> <span class="toc-text">哈希表求ASL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%8E%92"><span class="toc-number">2.10.</span> <span class="toc-text">快排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92"><span class="toc-number">2.11.</span> <span class="toc-text">堆排</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/template/" title="It’is me.">It’is me.</a><time datetime="2024-07-24T00:42:10.776Z" title="发表于 2024-07-24 00:42:10">2024-07-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/dp/" title="区间dp学习笔记">区间dp学习笔记</a><time datetime="2024-03-03T00:57:59.000Z" title="发表于 2024-03-03 00:57:59">2024-03-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/ds/" title="How to learn Data Structure and Algorithm in ONE DAY">How to learn Data Structure and Algorithm in ONE DAY</a><time datetime="2023-12-19T21:20:59.000Z" title="发表于 2023-12-19 21:20:59">2023-12-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 白芷</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>